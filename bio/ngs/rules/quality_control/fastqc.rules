# vim: syntax=python tabstop=4 expandtab
# coding: utf-8


"""
Rules for analysing fasta files with FastQC.

For usage, include this in your workflow.
"""


__author__ = "Johannes KÃ¶ster (http://johanneskoester.bitbucket.org), Ino de Bruijn (http://ino.pm)"
__license__ = "MIT"


# Check values in config file
CONFIG_REQS = ["reads"]
if "fastqc_rules" not in config:
    raise(Exception("fastqc_rules key not in config file"))
for cr in CONFIG_REQS:
    if cr not in config["fastqc_rules"]:
        raise(Exception("{cr} not in config file".format(cr=cr)))


def get_fasta_basename(filename):
    """Return basename of fasta/fastq file"""
    filename = os.path.basename(filename)
    possible_ext = [".fastq", ".fq.gz", ".fastq.gz", ".fasta", ".fa", ".fa.gz",
        ".fasta.gz"]
    for e in possible_ext:
        if filename.endswith(e):
            return filename[:-len(e)]
    return filename

import os


rule fastqc:
    """Generates fastqc output for given fastq or fastq.gz file. The reads can
    be specified in the config file but this is not necessary."""
    input:
        lambda wildcards: \
            ["fastqc/{}".format(os.path.basename(r)) for r in config["fastqc_rules"]["reads"] \
                if get_fasta_basename(r) == os.path.basename(wildcards.prefix)]\
            or glob.glob(wildcards.prefix + ".fa*") \
            or "{}.{{fastq.gz,fastq}}".format(wildcards.prefix)
    output:
        "{prefix}_fastqc.zip",
        "{prefix}_fastqc.html"
    shell:
        """
        {config[fastqc_rules][load_env]}
        fastqc {input}
        """


rule create_read_symlink:
    """Create symbolic links for given reads"""
    input:
        lambda wildcards: config["fastqc_rules"]["reads"][wildcards.reads]
    output:
        "fastqc/{reads}"
    shell:
        """
        ln -s {input} {output}
        """


rule fastqc_all:
    input:
        links=expand("fastqc/{reads}", reads=config["fastqc_rules"]["reads"]),
        htmls=expand("fastqc/{reads}_fastqc.html", reads=[get_fasta_basename(v) for v in config["fastqc_rules"]["reads"].values()]),
        zips=expand("fastqc/{reads}_fastqc.zip", reads=[get_fasta_basename(v) for v in config["fastqc_rules"]["reads"].values()])


import glob

rule fastqc_report:
    input:
        htmls=sorted(rules.fastqc_all.input.htmls),
        zips=sorted(rules.fastqc_all.input.zips),
        readme_rst=glob.glob("report/fastqc/README.rst")
    output:
        report="report/fastqc/index.html"
    params:
        htmls_basename=[os.path.basename(h) for h in sorted(rules.fastqc_all.input.htmls)],
        readme_html="report/fastqc/README.html"
    shell:
        """
        cp --parents {input.htmls} report/
        (
            htmls=( {params.htmls_basename} )
            zips=( {input.zips} )
            echo '<html><head><style>body {{ text-align: center }}</style></head><body>'
            echo '<h1>FastQC</h1>'
            for i in $(seq 0 $((${{#htmls[@]}}-1))); do
                echo "<a href='${{htmls[$i]}}'>${{htmls[$i]}}</a> "
                echo "PASS:$(unzip -p ${{zips[$i]}} '*/summary.txt' | grep -c PASS) "
                echo "WARN:$(unzip -p ${{zips[$i]}} '*/summary.txt' | grep -c WARN) "
                echo "FAIL:$(unzip -p ${{zips[$i]}} '*/summary.txt' | grep -c FAIL)"
                echo "<br />"
            done
            for f in {input.readme_rst}; do
                echo "<iframe style='width: 80%; height: 100%;' frameBorder=0 src='README.html'></iframe>"
                rst2html.py $f > {params.readme_html}
            done
            echo '</body></html>'
        ) > {output.report}
        """


rule fastqc_clean:
    """Remove FastQC dir"""
    shell:
        """
        rm -rf fastqc/
        """
